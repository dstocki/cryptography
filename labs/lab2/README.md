# List 2 - finite fields and elliptic curves

---

## ðŸ§  Tasks summary

### **Task 1**
Implement a generic structure for arithmetic over finite fields of form $\mathbb{F}\_{p^k}$ for a prime $p$. In particular, focus on extensions of $\mathbb{F}\_p$ as polynomial rings over $\mathbb{F}\_p$ modulo an irreducible polynomial of degree $k$.

The implementation should allow the user to at least perform the basic field operations, that is:

- **Addition:** $a + b$
- **Negation:** $-a$
- **Substraction as addition with negation:** $a + (-b) = a - b$
- **Multiplication:** $a \cdot b$
- **Inverse:** $a^{-1}$
- **Division as multiplication by inverse:** $a \cdot b^{-1} = a / b$

Additionaly, implement exponentiation - repeated multiplication - using an efficient algorithm, that is, exponentiation $a^\text{exp}$ should have complexity $O(\log(\text{exp}))$ of multiplications.

In cryptography, you may encounter finite fields of various size, but public-key cryptography typically requires at least 256 bits, so take "big integers" into account. Your structure does not have to be dynamically sized and may be compile-time configurable, but must support 256, 512, 1024 (and so on) -bit elements.

Prepare the implementatin in such a way that there are specialized interfaces for the "edge" cases of $k = 1$ and $p = 2$, where the $k = 1$ case is reduced to just an $\mathbb{F}\_p$ and $\mathbb{F}\_{2^k}$ element can be represented as bit strings. The case $\mathbb{F}\_{2^k}$ is also commonly referred to as $\mathbb{F}\_{2^m}$ or simply $\mathbb{F}2m$.

Note on the implementation: when dealing with bit strings we usually start counting from the first bit of the first byte (i.e. "Little Endian" byte order), while when dealing with large integers, we usually use a "Big Endian" notation with the most significant digits first. This is not a hard requirement for the internal representation, but a hint as to why we may encounter one or the other in the wild.

Your structure should take $p$ and an irreducible polynomial over $\mathbb{F}\_p$ as input (when $k > 1$). Optionally, you may implement a separate procedure for generating such polynomials.

> [!INFO]
> 
> **Field** - triplet $(F, +, \cdot)$, where:
> - $(F, +)$ - is an Abelian group
> - $(F, \cdot)$ - is an Abelian group
> - $(\forall_{a, b, c} \in F)(a \cdot (b + c) = a \cdot b + b \cdot c)$
> 
> **Finite field** - we call a field finite iff $|F| < \infty$
> 
> **Field $\mathbb{F}\_p$** - we define $\mathbb{F}\_p = \mathbb{Z} / p\mathbb{Z} = (\{0, 1, ..., p - 1\}, +_n, \cdot_n)$ for a prime number $p$, where:
> - $a +_n b = (a + b) \bmod p$
> - $a \cdot_n b = (a \cdot b) \bmod p$
>
> **Polynomial ring $\mathbb{F}\_{p}[x]$** - we define $\mathbb{F}\_p[x]$ as a triplet $(\{a_0 + a_1x + a_2x^2 + \ldots + a_nx^n : a_i \in F_p, n \geq 0\}, +_n, \cdot_n)$
> 
> **Irreducible polynomial** - $f(x) \in \mathbb{F}\_p[x]$ of degree $k \geq 1$ is called irreducible if $f(x) = g(x)h(x)$ implies that $deg(g) = 0 \; \lor \; deg(h) = 0$
> 
> **Ideal generated by $f(x)$** - we define $(f(x)) = \{f(x) \cdot g(x) : g(x) \in \mathbb{F}\_p[x]\}$
> 
> **Quotient ring of the polynomial ring** - we define $\mathbb{F}\_{p^k} = \mathbb{F}\_p / (f(x))$ as a triplet $({g(x) + (f(x)) : g(x) \in \mathbb{F}\_p[x]})$. Two polynomials $g, h$, represent the same element of quotient iff $g(x) \equiv h(x) \bmod f(x)$. Each class is represented by a single polynomial of degree $< k$.
> 
> **Wedderburn's theorem** - finite field $\mathbb{F}\_{p^k}$, where $f(x) \in \mathbb{F}\_p[x]$ is irreducible and $deg(f) = k$ has exactly $p^k$ elements.
> 
> **Element of $\mathbb{F}\_{p^k}$** - an element of $\mathbb{F}\_{p^k}$ is an polynomial equivalence class, which is a unique polynomial $a(x) = a_0 + a_1x + \ldots + a_{k - 1}x^{k - 1}$ with $a_i \in \mathbb{F}\_p$, so from mathematical point of view, we have $\mathbb{F}\_{p^k} \cong \mathbb{F}\_p^k$. 
